# 官方题解

## 方法一：动态规划

### 算法

考虑所有可能的抢劫方案过于困难。一个自然而然的想法是首先从最简单的情况开始。记：

> $f(k)$ = 从前 $k$ 个房屋中能抢劫到的最大数额，$A_i$ = 第 $i$ 个房屋的钱数。

首先看 $n=1$ 的情况，显然 $f(1)=A_1$。

再看 $n=2$，$f(2)=\rm{max}(A_1,A_2)$。

对于 $n=3$，有两个选项：

1. 抢第三个房子，将数额与第一个房子相加。
2. 不抢第三个房子，保持现有最大数额。

显然，你想选择数额更大的选项。于是，可以总结出公式：

$$
f(k) = \rm{max}(f(k-2)+A_k, f(k-1))
$$

我们选择 $f(–1) = f(0) = 0$ 为初始情况，这将极大地简化代码。

答案为 $f(n)$。可以用一个数组来存储并计算结果。不过由于每一步你只需要前两个最大值，两个变量就足够用了。

**Java:**

```java
public int rob(int[] num) {
    int prevMax = 0;
    int currMax = 0;
    for (int x : num) {
        int temp = currMax;
        currMax = Math.max(prevMax + x, currMax);
        prevMax = temp;
    }
    return currMax;
}
```

### 复杂度分析

* 时间复杂度：$O(n)$。其中 $n$ 为房子的数量。
* 时间复杂度：$O(1)$。
